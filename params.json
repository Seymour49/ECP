{
  "name": "Ecp",
  "tagline": "",
  "body": "#################################################################################\r\n#\tECP est un algorithme de recherche locale ayant\tpour but de résoudre le #\r\n#\tproblème de coloration équitable sur différents graphes présents dans   #\r\n#\tla littérature.\t\t\t\t\t\t\t\t#\r\n#\tDans un premier temps, nous implémenterons l'algorithme décrit dans\t#\r\n#\tl'article \"Backtracking Based Iterated Tabu Search for Equitable \t#\r\n#\tColoring\" disponible à l'adresse :\t\t\t\t\t#\r\n#\thttp://www.info.univ-angers.fr/pub/hao/papers/LaiHaoGloverEAAI2015.pdf  #\r\n#################################################################################\r\n\r\n\r\nReprésentation d'un graphe\r\n--------------------------\r\n\r\n\tUne classe a été reservée à la représentation d'un graphe G=(V,E). Cette \r\n\tclasse dispose des éléments suivants :\r\n\t\t- int nbVertices, nbEdges : entier représentant |V| et |E|\r\n\t\t- string namefile : string représentant le path du fichier source au \r\n\t\t  format DIMACS du graphe étudié\r\n\t\t- vector< vector<bool> > G : matrice de booléen de taille |V|*|V| \r\n\t\t  correspondant à la fonction f :\r\n\t\t\tf(i,j) = 1 si (i,j) ? E, i,j ? V\r\n\t\t\t\t\t 0 sinon.\r\n\t\t\r\n\t\t- un getter spécifique getMatriceValue(int x, int y) retournant la val-\r\n\t\t  eur de M[x][y]\r\n\t\t  \r\nColoration équitable d'un graphe\r\n--------------------------------\r\n\r\n\tSoit le graphe G=(V,E). Une coloration équitable de ce graphe est un en-\r\n\tsemble Vk de k partitions de V tel :\r\n\t\t- qu'aucun des sommets appartenant à une partition Vk[i] ne soit \r\n\t\t  adjacent à un autre sommet de cette partition dans G. [1]\r\n\t\t- que la taille de chaque partition ne diffère au plus que de 1. [2]\r\n\t\t\r\n\tUne telle coloration étant le but de notre recherhe locale, nous nous\r\n\tattacherons à toujours respecter la contrainte [2] et à effectuer notre\r\n\trecherche via la contrainte [1].\r\n\t\r\n\tPour représenter cette coloration, nous disposons d'une classe avec les \r\n\tattributs suivants :\r\n\t\t- Graphe* G : pointeur sur le graphe à colorer\r\n\t\t- int nbColor : représente le nombre de couleurs utilisées.\r\n\t\t- vector< vector<int> > Vk : ensemble des partitions des sommets de G. \r\n\t\t- vector< vector<int> > M : matrice |V|*nbColor où M[i][j] représente \r\n\t\t  le nombre de sommmets adjacents au sommet i de couleur j.\r\n\t\t  \r\n\tInitialisation d'une coloration\r\n\t-------------------------------\r\n\tL'algorithme suivant est utilisé pour créer une coloration équitable initiale.\r\n\t\r\n\tPour(i=0; i < nbColor; ++i){\r\n\t  selectionner un sommet Sj aléatoire dans U.\r\n\t  Vk[i] = Vk[i] + Sj.\r\n\t  U = U \\ Sj.\r\n\t}\r\n\t\r\n\ti=0;\r\n\t\r\n\tTant que ( !vide(U) ){\r\n\t  selectionner le sommet Sj ayant le moins de voisin dans la couleur i.\r\n\t  Vk[i] = Vk[i] + Sj.\r\n\t  U = U \\ Sj.\r\n\t  i = (i+1) % nbColor.\r\n\t}\r\n\t\r\n\t\r\n\tAjout de la recherche tabou\r\n\t---------------------------\r\n\t\r\n\t\r\n\tEvaluation d'une coloration\r\n\t---------------------------\r\n\tLa fonction évalue le nombre de sommets en conflit. Un sommet est en conflit si\r\n\tun de voisins possède la même couleur. Pour ce faire, nous utilisons l'algo-\r\n\trithme suivant :\r\n\t\r\n\ttotal = 0.\r\n\tPour(i=0; i < Vk.size(); ++i){\r\n\t  Pour(j=0; j < Vk[i].size(); ++j){\r\n\t    total += (int)(M[Vk[i][j]][i] != 0);\r\n\t  }\r\n\t}\r\n\t\r\n\t\r\n\tDéfinition du voisinage\r\n\t-----------------------\r\n\tLe voisinage d'une solution s est l'union de deux voisinages décrits comme suit :\r\n\t\r\n\tN(s) = N1(s) U N2(s) où :\r\n\t  - N1(s) = { <Sj, Vi,Vj> | Sj ? Vi n C(s), i != j, |Vk[i]| > floor(|V|/nbColor),\r\n\t    |Vk[j]| < top(|V|/nbColor) } où C(s) représente l'ensemble des sommets en \r\n\t    conflits de la solution courante s.\r\n\t  \r\n\t  - N2(s) = { (Si,Sj) | Si ? Vk[i], Sj ? Vk[j], i != j, {Si,Sj} n C(s) != {}  }\r\n\t  \r\n\tPlusieurs choix s'offrent à nous pour la représentation de ces deux voisinages. \r\n\tEn effet, nous pouvons à la fois définir une classe abstraite N puis deux sous-classes\r\n\tN1 et N2 implémentant chacun un voisinage puis travailler sur un ensemble d'objets de \r\n\ttype N. \r\n\tNous pourrions également travailleur sur deux vecteurs différents représentant chacun\r\n\tun voisinage.\r\n\tDe nombreuses autres implémentations sont possibles et nous reviendrons dessus si le \r\n\ttemps nous le permet.\t\r\n\tDe plus, la recherche tabou présentée utilisant une stratégie de sélection du meilleur\r\n\taméliorant,nous ajouterons à chacun des voisins le score de gain qui lui est associé.\r\n\tNous présenterons le calcul de ce gain dans la prochaine section.\r\n\tAinsi, nous disposons d'une classe \"mère\" Voisin, disposant d'un gain et de deux classes\r\n\t\"filles\" implémentant les voisinages OneMove et Swap. Nous n'utiliserons donc qu'un\r\n\tseul vecteur.\r\n\t\r\n\t    - class Voisin {\r\n\t    \t[...]\r\n\t    \tprivate:\r\n\t    \t   int gain;\r\n\t    }\r\n\t    \r\n\t    - class OneMove : public Voisin{\r\n\t        [...]\r\n\t\tprivate:\r\n\t          int Sj;\r\n\t\t  int Vi;\r\n\t\t  int Vj;\r\n\t      };\r\n\t      \r\n\t    - class Swap :public Voisin {\r\n\t    \t[...]\r\n\t\tprivate:\r\n\t\t  int Si;\r\n\t\t  int Sj;\r\n\t\t  int Ki;\r\n\t\t  int Kj;\r\n\t      };\r\n\t      \r\n\t    vector<Voisin *> N = N1 Union N2;\r\n\t  \r\n\tCalcul du gain\r\n\t--------------\r\n\tAfin de sélectionner le meilleur améliorant, nous avons mis en place une procédure \r\n\td'évaluation d'un voisin v dépendant du type de mouvement choisi. Cette procédure\r\n\test basée sur la matrice  M définie précedemment.\r\n\t\r\n\t- OneMove : delta(<s,i,j>) : M[s][Vk[j]] - M[s][Vk[i]]\r\n\t\r\n\t- Swap : delta(<u,v,ku,kv>) : M[v][ku] - M[v][kv] + (M[u][kv] - M[u][ku] - 2*G[u][v])\r\n\t\t\r\n\tMise à jour de la coloration après un mouvement\r\n\t-----------------------------------\r\n\tAprès avoir sélectionné un mouvement autorisé, deux opérations doivent être effectuées :\r\n\tla mise à jour de M et la mise à jour de Vk. Une fonction de validation par type de \r\n\tvoisinage a donc été créée.\r\n\t\r\n\tvalidMovement(Voisin *N){\r\n\t    // dynamic_cast et appel à la fonction correspondante\r\n\t}\r\n\t\r\n\tvalidOneMove(OneMove *om){\r\n\t    // MaJ M\r\n\t    for(i=0; i < |V|; ++i){\r\n\t\tif( G[om->getS()][i] == 1 ){ // sommets voisins\r\n\t\t    M[i][om->getVki()] -= 1;\r\n\t\t    M[i][om->getVkj()] += 1;\r\n\t\t}\r\n\t    }\r\n\t    \r\n\t    // MaJ Vk\r\n\t    Vk[om->getVki()].erase( remove(Vk[om->getVki()].begin(), Vk[om->getVki()].end(), om->getS()), Vk[om->getVki()].end() );\r\n\t    Vk[om->getVkj()].push_back(om->getS());\r\n    \r\n\t}\r\n\t\r\n\tvalidSwap(Swap *s){\r\n\t    // MàJ de M --> correspond à deux OneMove consécutifs\r\n\t    for(int i=0; i < |V|; ++i){\r\n\t\t// Les sommets s et i sont voisins\r\n\t\tif( G[s->getSi()][i] == 1){\r\n\t\t    M[i][s->getKi()] -= 1;\r\n\t\t    M[i][s->getKj()] += 1;\r\n\t\t}\r\n\t    \r\n\t\tif(G->getMatriceValue(s->getSj(),i) == 1){\r\n\t\t    M[i][s->getKj()] -= 1;\r\n\t\t    M[i][s->getKi()] += 1;\r\n\t\t}\r\n\t    }\r\n    \r\n\t    // Mise à jour de Vk_\r\n\t    Vk[s->getKi()].erase( remove(Vk[s->getKi()].begin(), Vk[s->getKi()].end(), s->getSi()), Vk[s->getKi()].end() );\r\n\t    Vk[s->getKj()].push_back(s->getSi());\r\n\t    \r\n\t    Vk[s->getKj()].erase( remove(Vk[s->getKj()].begin(), Vk[s->getKj()].end(), s->getSj()), Vk[s->getKj()].end() );\r\n\t    Vk[s->getKi()].push_back(s->getSj());\r\n\r\n\t}\r\n\t\r\n\t\r\n\tGestion de la liste tabou\r\n\t-------------------------\r\n\tUne fois un mouvement de voisinage effectué et la matrice M mise à jour, il convient\r\n\td'interdire au(x) sommet(s) ayant changé de classe de couleur d'y revenir avant un \r\n\tcertain nombre d'itérations via la mise en place d'une matrice tabou.\r\n\tDe fait, si un voisin OneMove <S,Vi,Vj> est sélectionné, le mouvement suivant est \r\n\tinterdits :\r\n\t\t- (S,Vi)\r\n\tSi le voisin appliqué est un Swap <Si,Sj,Ki,Kj>, les mouvements suivants sont interdits :\r\n\t\t- (Si,Ki)\r\n\t\t- (Sj,Kj)\r\n\t\t\r\n\tAinsi, cette matrice tabou de taille |V|*k est telle que MT[u][k] représente l'itération\r\n\tjusqu'à laquelle le mouvement consistant à déplacer le sommet u vers la couleur k a été\r\n\tou sera interdit. Nous devons donc définir une fonction pour vérifier qu'un mouvement \r\n\tn'est pas interdit et une fonction pour mettre à jour l'itération jusqu'à laquelle\r\n\tsera interdit un mouvement après son application. Soit ß le nombre d'itérations pendant\r\n\tlequel un mouvement est interdit après application.\r\n\t\r\n\tisForbidden(Voisin *N, int iter){\r\n\t    // dynamic_cast et appel à la fonction correspondante\r\n\t}\r\n\t\r\n\tisForbiddenSwap(Swap * s, int iter){\r\n\t    return ( MT[s->getSi()][s->getKj()] > iter || MT[s->getSj()][s->getKi()] > iter );\r\n\t}\r\n\t\r\n\tisForbiddenOneMove(OneMove *om, int iter){\r\n\t    return ( MT[om->getS()][om->getVkj()] > iter );\r\n\t}\r\n\t\t\r\n\tLa mise à jour de la matrice MT s'effectue dans le corps de la fonction run() de notre\r\n\trecherche tabou. Une fois le voisin selectionné et validé, on met à jour tabuMat via un\r\n\tdynamic_cast sur le voisin choisi :\r\n\t\r\n\ttry{\r\n\t    if( dynamic_cast<Swap*>(N[indN]) == 0 ){\r\n\t\t// OneMove\r\n\t\tOneMove * om = dynamic_cast<OneMove*>(N[indN]);\r\n\t\ttabuMat[om->getS()][om->getVki()] = iteration + tabuTenure;\r\n\t\tcurrent.validOneMove(om);\r\n\t\t\r\n\t    }else{\r\n\t\tSwap* s = dynamic_cast<Swap*>(N[indN]);\r\n\t\ttabuMat[s->getSi()][s->getKi()] = iteration + tabuTenure;\r\n\t\ttabuMat[s->getSj()][s->getKj()] = iteration + tabuTenure;\r\n\t\tcurrent.validSwap(s);\r\n\t    }\r\n\t}catch(exception &e){\r\n\t     cerr << \"Exception: \" << e.what();\r\n\t     exit(EXIT_FAILURE);\r\n\t}\r\n\t\r\n\t\r\n\tAspiration\r\n\t----------\r\n\t    L'aspiration consiste lorsqu'un mouvement est interdit par la matrice Tabu a le selectionné\r\n\tquand même s'il conduit à une solution meilleure que la meilleure actuellement déterminée.\r\n\tPour faire cette vérification de manière peu coûteuse, nous utiliserons l'algorithme suivant.\r\n\tLittéralement, nous vérifions pour chaque sommet s'il est voisin avec le sommet impliqué dans le\r\n\tmouvement. Si oui, nous vérifions les éventuelles correspondances entre couleur et modifions\r\n\tle résultat en conséquence. Par exemple, pour un voisin de type OneMove :\r\n\t\r\n\t    int result = 0;\r\n\t    for(int i=0; i < nbColor; ++i){\r\n\t\tfor(unsigned j=0; j < Vk[i].size(); ++j){\r\n\t\t    \r\n\t\t    if( (G->getMatriceValue(Vk[i][j],om->getS()) == 1) && (i == om->getVkj()) ){\r\n\t\t\t// Pas besoin de test car on ferait (M[.][.] + 1) != 0 --> Tautologie car M[][] >=0\r\n\t\t\t++result;\r\n\t\t    }\r\n\t\t    else if( (G->getMatriceValue(Vk[i][j],om->getS()) == 1) && (i == om->getVki()) ){\r\n\t\t\tresult += ( (M[Vk[i][j]][i]-1) != 0 ); \r\n\t\t    }\r\n\t\t    else{\r\n\t\t\tresult += ( M[Vk[i][j]][i] != 0);\r\n\t\t    }   \r\n\t\t}\r\n\t    }\r\n\t    return result;\r\n\t    \r\n\tGestion de la tabu tenure et de la profondeur de la recherche\r\n\t-------------------------------------------------------------",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}